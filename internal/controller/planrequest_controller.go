// Copyright 2026 The KubeAegis Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/*
Copyright 2026 KubeAegis Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package controller

import (
	"context"
	"fmt"
	cortexv1alpha1 "github.com/KGEmmanuel/KubeAegis/api/v1alpha1"
	"github.com/KGEmmanuel/KubeAegis/internal/planner"
	"k8s.io/apimachinery/pkg/runtime"
	ctrl "sigs.k8s.io/controller-runtime"
	"sigs.k8s.io/controller-runtime/pkg/client"
	"sigs.k8s.io/controller-runtime/pkg/log"
)

// PlanRequestReconciler reconciles a PlanRequest object
type PlanRequestReconciler struct {
	client.Client
	Scheme *runtime.Scheme
}

// +kubebuilder:rbac:groups=cortex.kubecortex.io,resources=planrequests,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups=cortex.kubecortex.io,resources=planrequests/status,verbs=get;update;patch
// +kubebuilder:rbac:groups=cortex.kubecortex.io,resources=planrequests/finalizers,verbs=update

// Reconcile is part of the main kubernetes reconciliation loop which aims to
// move the current state of the cluster closer to the desired state.
// TODO(user): Modify the Reconcile function to compare the state specified by
// the PlanRequest object against the actual cluster state, and then
// perform operations to make the cluster state reflect the state specified by
// the user.
//
// For more details, check Reconcile and its Result here:
// - https://pkg.go.dev/sigs.k8s.io/controller-runtime@v0.23.0/pkg/reconcile
func (r *PlanRequestReconciler) Reconcile(
	ctx context.Context,
	req ctrl.Request,
) (ctrl.Result, error) {

	log := log.FromContext(ctx)

	var plan cortexv1alpha1.PlanRequest
	if err := r.Get(ctx, req.NamespacedName, &plan); err != nil {
		return ctrl.Result{}, client.IgnoreNotFound(err)
	}

	// Phase: Pending â†’ Planning
	if plan.Status.Phase == "" {
		plan.Status.Phase = "Planning"
		plan.Status.Reason = "Routing intent to cognitive planner"
		_ = r.Status().Update(ctx, &plan)
		return ctrl.Result{Requeue: true}, nil
	}

	// === REAL Cognitive Planner (Eino) ===
	if plan.Status.Phase == "Planning" {
		log.Info("ðŸ§  Consulting Eino Brain...", "intent", plan.Spec.Intent)

		// 1. Initialize the Brain (Hybrid: Cloud or Local)
		brain, err := planner.NewBrain(ctx)
		if err != nil {
			log.Error(err, "Failed to initialize AI Brain")
			// We return error to retry, but you might want to backoff
			return ctrl.Result{}, err
		}

		// 2. Ask the Brain to generate the Manifest
		yaml, err := brain.GenerateManifest(ctx, plan.Spec.Intent)
		if err != nil {
			log.Error(err, "Brain failed to generate manifest")
			// Update status to failed so we don't loop forever on a bad prompt
			plan.Status.Phase = "Failed"
			plan.Status.Reason = fmt.Sprintf("AI Generation Error: %v", err)
			_ = r.Status().Update(ctx, &plan)
			return ctrl.Result{}, nil
		}

		log.Info("âœ¨ Plan Generated Successfully")

		// 3. Update Status with the real YAML
		plan.Status.GeneratedPlan = yaml
		plan.Status.Phase = "Validating"
		plan.Status.Reason = "Plan generated by Eino (Go-Native)"

		if err := r.Status().Update(ctx, &plan); err != nil {
			return ctrl.Result{}, err
		}

		// Success! Move to next phase
		return ctrl.Result{Requeue: true}, nil
	}

	// === MOCKED Constitutional Proxy ===
	if plan.Status.Phase == "Validating" {
		log.Info("Running policy validation")

		// Example rejection
		if plan.Spec.DryRun {
			plan.Status.Phase = "Rejected"
			plan.Status.PolicyViolations = []string{
				"DryRun requests cannot be executed",
			}
			_ = r.Status().Update(ctx, &plan)
			return ctrl.Result{}, nil
		}

		plan.Status.Phase = "Executing"
		plan.Status.Reason = "Plan approved by policy engine"
		_ = r.Status().Update(ctx, &plan)
		return ctrl.Result{Requeue: true}, nil
	}

	// === MOCKED Execution ===
	if plan.Status.Phase == "Executing" {
		log.Info("Executing verified plan")

		plan.Status.Phase = "Completed"
		plan.Status.Reason = "Plan successfully applied"
		_ = r.Status().Update(ctx, &plan)
	}

	return ctrl.Result{}, nil
}

// SetupWithManager sets up the controller with the Manager.
func (r *PlanRequestReconciler) SetupWithManager(mgr ctrl.Manager) error {
	return ctrl.NewControllerManagedBy(mgr).
		For(&cortexv1alpha1.PlanRequest{}).
		Named("planrequest").
		Complete(r)
}
